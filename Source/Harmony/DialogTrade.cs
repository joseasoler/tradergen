using System.Collections.Generic;
using HarmonyLib;
using RimWorld;
using TG.TraderKind;
using Verse;

namespace TG.Harmony
{
	/// <summary>
	/// Patches the trade dialog to take into account TraderGen additions.
	/// </summary>
	public static class DialogTrade
	{
		/// <summary>
		/// Returns a TraderGen trader label to use in the trade dialog.
		/// </summary>
		/// <param name="originalLabel">Original label. This method is just ignoring it.</param>
		/// <returns>New label to use.</returns>
		public static TaggedString TaggedLabel(TaggedString originalLabel)
		{
			return Util.Label(TradeSession.trader);
		}

		/// <summary>
		/// Apply the Harmony patches for trade dialog compatibility.
		/// </summary>
		/// <param name="harmony">Harmony library instance.</param>
		public static void Patch(HarmonyLib.Harmony harmony)
		{
			var tradeWindowContents = AccessTools.Method(typeof(Dialog_Trade), nameof(Dialog_Trade.DoWindowContents));
			var tradeWindowTranspiler =
				new HarmonyMethod(AccessTools.Method(typeof(DialogTrade), nameof(InjectSpecializations)));
			harmony.Patch(tradeWindowContents, transpiler: tradeWindowTranspiler);
		}

		private static IEnumerable<CodeInstruction> InjectSpecializations(IEnumerable<CodeInstruction> instructions)
		{
			var labelCapGetter = AccessTools.PropertyGetter(typeof(Def), nameof(Def.LabelCap));

			foreach (var code in instructions)
			{
				yield return code;
				if (code.Calls(labelCapGetter))
				{
					// Will swallow the label generated by the original code and replace it with TraderGen's label.
					yield return CodeInstruction.Call(typeof(DialogTrade), nameof(TaggedLabel));
				}
			}
		}
	}
}