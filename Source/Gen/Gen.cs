using System.Collections.Generic;
using RimWorld;
using TG.Mod;
using TG.StockGen;

namespace TG.Gen
{
	/// <summary>
	/// Generates Trader data randomly using an initial NodeDef.
	/// </summary>
	public static class Gen
	{
		/// <summary>
		/// Adds stock generator data found in a NodeDef to the GenResult being generated.
		/// </summary>
		/// <param name="nodeDef">NodeDef being evaluated.</param>
		/// <param name="fromTile">Map tile considered as the origin of the trader.</param>
		/// <param name="faction">Faction of the trader.</param>
		/// <param name="result">Results of the generation process.</param>
		private static void ApplyGenerators(in NodeDef nodeDef, in int fromTile, in Faction faction, ref GenResult result)
		{
			foreach (var generator in nodeDef.generators)
			{
				// Stock generated by TG StockGenerators may change depending on the original tile and faction of the trader.
				if (generator.GetType().IsSubclassOf(typeof(TG.StockGen.StockGen)))
				{
					((TG.StockGen.StockGen) generator).SetTraderInfo(fromTile, faction);
				}

				result.generators.Add(generator);

				if (!Settings.LogGen || !Settings.LogStockGen) continue;
				Logger.Gen(Util.ToText(generator).ToString());
			}
		}

		/// <summary>
		/// Applies all changes required by a specific node to the generated trader.
		/// </summary>
		/// <param name="nodeDef">NodeDef being evaluated.</param>
		/// <param name="fromTile">Map tile considered as the origin of the trader.</param>
		/// <param name="faction">Faction of the trader.</param>
		/// <param name="result">Results of the generation process. Null if an irrecoverable error happened.</param>
		private static void ApplyNode(in NodeDef nodeDef, in int fromTile, in Faction faction, ref GenResult result)
		{
			ApplyGenerators(nodeDef, fromTile, faction, ref result);
		}

		/// <summary>
		/// Algorithm for procedural generation of traders.
		/// The caller is responsible for pushing the random seed using Rand.PushState before calling this function, and for
		/// popping the seed after the Generate call is done.
		/// </summary>
		/// <param name="def">Node used to generate the trader.</param>
		/// <param name="fromTile">Map tile considered as the origin of the trader.</param>
		/// <param name="faction">Faction of the trader.</param>
		/// <returns>Result of the generation process.</returns>
		public static GenResult Generate(in NodeDef def, in int fromTile, in Faction faction)
		{
			const int maximumNodesThreshold = 128;

			Logger.Gen($"Generating using node {def.defName}.");

			var result = new GenResult();

			var pending = new Queue<NodeDef>();
			pending.Enqueue(def);

			while (pending.Count > 0)
			{
				if (pending.Count > maximumNodesThreshold)
				{
					Logger.ErrorOnce(
						$"Error generating {def.defName}: maximum number of nodes allowed is {maximumNodesThreshold}");
					return null;
				}

				var current = pending.Dequeue();
				ApplyNode(current, fromTile, faction, ref result);
				current.next?.Nodes(current, fromTile, faction).ForEach(newNodeDef => pending.Enqueue(newNodeDef));
				Logger.Gen($"Processed {current.defName}. {pending.Count} nodes remaining.");
			}

			return result;
		}
	}
}